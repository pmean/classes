---
title: "r-03-05, Special cases"
format: 
  revealjs:
    slide-number: true
    embed-resources: true
editor: source
---

## A special case

+ Type the following into notepad
  + Three spaces between the 1 and 4
  + Three spaces between the 2 and 8
  + Two spaces between the 3 and 12
  + Two spaces between the 4 and 16

```{r white-space, echo=FALSE, comment=""}
tx <- read_lines("../data/white-space.txt")
cat(tx, sep="\n")
```

+ Save as white-space.txt


::: notes

Here's a special case of fixed width format.

Sometimes a fixed width file will include enough blanks so that each data value is separated from any other data value. This requires more room, but it makes the data file easier to read.
Create a fixed width file in notepad with the following lines.

1   4

2   8

3  12

4  16

and store it as white-space.txt.

:::

## White-space delimited files

```{r read_table}
fn <- "../data/white-space.txt"
raw_data <- read_table(fn,
  col_names=c("x", "y"),                     
  col_types="nn")
```

::: notes

The read_table function will use "white space" as a delimiter. White space is defined as one or more blanks or tabs or even a mix of spaces and tabs.

Note you can also use col_names=FALSE here.

Now, you could also use read_fwf for this dataset.

:::

## Display the white-space data

```{r disaply-white-space}
raw_data
```

::: notes

The data has been read in properly.

:::

## Reading character data

+ Also know as
  + string data, or
  + alphanumeric data
+ Character data is data composed of 
  + letters, or
  + a mix of letters, symbols, and numbers
+ Easier in R than in SAS

::: notes

Character data is data that is composed entirely of the letters A-Z upper case and a-z lower case. So a person's name (Steve) is character data. You can also mix in numbers. So a person's address (1600 Pennsylvania Avenue) is character data. A phone number is character data because it might include parentheses or dashes.

R can handle character data more easily than SAS. Often you do not have to do anything and R will figure things out for you. In SAS you ALWAYS have to designate character data. When the lengths of the character data vary, you have to be careful. When the length of the characters is greater than 8, you have to be especially careful.

R can handle varying lengths easily and characters of length greater than 8 easily.

:::

## Potential problems

+ Values=1, 2, 3 or more
+ Embedded blanks (Steve Simon)
+ Delimiters (Simon, Steve)
+ Recommendation, use quotes
  + "1", "2", "3 or more"
  + "Steve Simon"
  + "Simon, Steve"

::: notes

There still are some issues, such as when the data is mostly numeric, and only sometimes character. An example would be data that has the values 1 (a number), 2 (also a number), and 3 or more (character data).

Embedded blanks are sometimes a problem (Steve space Simon) as are character data that include commonly used delimiters like a comma (simon, comma Steve).

The best thing to do, if there is any potential problems is to enclose your data in quotes.

:::

## String data

+ Type the following into notepad.

```{r string-data, echo=FALSE, comment=""}
tx <- read_lines("../data/string.csv")
cat(tx, sep="\n")
```

+ Save it
  + in the data directory
  + filename: string.csv

::: notes

:::

## Using string data

```{r string}
fn <- "../data/string.csv"
raw_data <- 
  read_csv(fn, 
  col_types="ccn")
```

::: notes

:::

## Display string data

```{r display-string-data}
raw_data
```

::: notes

The data has been read in correctly.

:::

## Break #6

+ What have you learned
  + Multiple blanks in a text file
  + Reading character data
+ What's next?
  + Advanced options when reading
  + Writing text files

## Advanced options when reading

+ col_select=
+ na=
+ name_repair=
+ skip=

::: notes

There are some nice options that I won't show in this video, but they are still worth noting.

You can use the col_select argument to read in only some of the columns of data. 

Use the na argument to designate codes for missing values. By default, R looks for NA or a width of zero. But sometimes, other symbols, such as an asterisk or a dot may represent missing values.

You can use the name_repair argument to suggest how to handle names that are duplicates or which violate the rules in R for variable names.

You can use the skip argument to ignore a certain number of rows before reading data.

:::

## Writing text files

+ Similar structure to read functions
  + write_csv
  + write_delim
  + write_tsv

::: notes

If you want to write a text file, you can use the write_csv, write_delim, or write_tsv functions. Look up the help files on these functions. We'll create a small data frame and store it in a comma delimited and tab delimited format.

:::

## Writing text files 

```{r write-text}
raw_data <- data.frame(
  x=c(1, 2, 3, 4), 
  y=c(4, 8, 12, 16))
fn <- "../results/output_data.txt"
write_csv(raw_data, fn)
```

::: notes

Open these files in notepad to see what they look like.

:::

## Writing text files

```{r output1, echo=FALSE}
tx <- read_lines(fn)
cat(tx, sep="\n")
```

::: notes

If you opened up the data in notepad or some other program, you would see a space delimited file. You can change the delimiter, among other things

:::

## Break #7

+ What have you learned
  + Advanced options when reading
  + Writing text files
+ What's next?
  + Some real world examples


## Example #1, binary.csv

![Figure 1. Excerpt from website](../images/binary-01.png)

::: notes

Let's look at some real world examples. The first one comes from one of the pages at the UCLA site on data analysis examples.

:::

## Example #1, the data

```{r ex1, echo=FALSE}
fn <- "../data/binary.csv"
tx <- read_lines(fn)
cat(tx[1:6], sep="\n")
```

::: notes

Peeking at the first six lines of data, you can see clearly that it is uses comma delimiter and the first row of data contains the variable names.

:::


## Example #1, the data dictionary

+ No formal data dictionary, but here is a description
  + "This dataset has a binary response (outcome, dependent) variable called admit. There are three predictor variables: gre, gpa and rank. We will treat the variables gre and gpa as continuous. The variable rank takes on the values 1 through 4. Institutions with a rank of 1 have the highest prestige, while those with a rank of 4 have the lowest."

::: notes

There is no formal data dictionary, which is a shame, but you can find a brief description on a second page where this data set is used.

:::

## Example #1, the code

```{r read-binary}
fn <- "../data/binary.csv"
raw_data <- read_csv(fn,
  col_types="nnnn")
```

::: notes

Choose the read_csv function and specify four numeric variables.

:::


## Example #1, the output

```{r display-binary}
raw_data
```

::: notes

The read.csv file does a fine job here.

:::

## Example #2, barbershop-music.txt

![Figure 2. Excerpt from website](../images/barbershop-00.png)

## Example #2, the data file

![](../images/barbershop-01.png)

::: notes

This is a second dataset. Looking at it in notepad, it looks like it is a tab delimited file. But you need to fix the file. The first two lines accidentally got stuck together.

:::

## Example #2, the data file, fixed

![](../images/barbershop-02.png)

::: notes

This is what the fixed file looks like. Normally, I discouraging modifying the data before you input it into R, but here a quick fix makes sense.

:::

## Example #2, the data dictionary

+ No data dictionary
  + Brief description: "At a barbershop music singing competition, choruses are judged on three scales: Music (quality of the arrangement, etc.), Performance, and Singing."

::: notes

There is no formal data dictionary, but the website does offer a brief description.

:::

## Example #2, the code

```{r read-tsa-3}
fn <- "../data/barbershop-music.txt"
raw_data <- read_tsv(fn,
  col_types="nnn")
```

::: notes

The read_tsv function works well here.

:::

## Example #2, the output

```{r display-example-2}
raw_data
```

::: notes

The data appears to have been read in nicely.

:::

## Example #3, airport.txt

![Figure 3. Excerpt from website](../images/airport-01.png)

::: notes

The third example comes from the Journal of Statistics Education website.

:::

## Example #3, the data file

![](../images/airport-in-browser.png)

::: notes

This is a third data set. Notice that there are no variable names at the top of the file.

:::

## Example #3, the data dictionary

+ Here is an excerpt from the data dictionary.

```{}
VARIABLE DESCRIPTIONS:
Airport                          Columns 1-21
City                             Columns 22-43 
Scheduled departures             Columns 44-49 
```

::: notes

This dataset has a very nice data dictionary. From the description, you can tell that it is a fixed width format.

:::

## Example #3, the code

```{r airport}
fn <- "../data/airport.txt"
raw_data <- read_fwf(fn, 
  fwf_cols(21, 22, 6, 7, 9, 10, 10),
  col_types="ccnnnnn")
```

::: notes

You have to do a bit of math here. If the first variable ends in column 21 and the second variable ends in column 43, then the number of columns for the second variable is 43-21.

:::

## Example #3, the output

```{r airport-print}
raw_data
```

## Links for examples 1-3

Data file links

1. https://stats.idre.ucla.edu/stat/data/binary.csv
2. https://dasl.datadescription.com/download/data/3061
3. http://jse.amstat.org/datasets/airport.dat.txt

Data dictionary links

1. https://stats.idre.ucla.edu/r/dae/logit-regression/
2. https://dasl.datadescription.com/datafile/barbershop-music/
3. http://jse.amstat.org/datasets/airport.txt

## Break #8

+ What have you learned
  + Some real world examples
+ What's next?
  + Some general advice

