---
title: "Module03: Reading text files"
author: "Steve Simon"
date: "Created 2020-02-08"
output: powerpoint_presentation
---

```{r echo=FALSE}
suppressMessages(suppressWarnings(library(stringr)))
options(width=45)
```

### Text files
+ Advantages
  + Easy import into many programs
  + Review using notepad
+ Wide range of formats
  + Delimited
  + Fixed width
+ First row for variable names
  + Optional but recommended
+ Always look for a data dictionary

<div class="notes">

One of the most important skils you will learn in this class is how to read data from text files. Text files are commonly used for data storage because they are easily imported into a variety of different programs. You can often peek at a text file using a simple program like Notepad in order to get a quick feel for what the data looks like.

Text files are popular because just about any program out there can read a text file. You can import a nontext format, one that has special binary characters, but this often limits the types of programs that can read the data. So people who want to make their data widely available will almost store that data in a text file.

Text files come in a variety of format. A delimited file uses a special character, often a comma, to designiate where one data value ends and the next one begins. In contrast, a fixed width file requires every variable to occupy a particular column or columns.

Many text files include the names of the variables in the first row of text. This is not required, but it is strongly recommended. I will talk about at least one example where you don't have the names of the variables in the first line of text.

Not every data set that you find is going to have a data dictionary but always look for it, because often that will give you some helpful advice. It will make it easier for you to read the data into a program like R. 

</div>

### Read in comma separated values

+ Type the following into notepad.

```{r csv, echo=FALSE, comment=""}
tx <- readLines("../data/simple.csv")
cat(tx, sep="\n")
```

+ Save it
  + in the data directory
  + filename: simple.csv

<div class="notes">

In notepad or another text editor, type in the following
values.

x,y

1,4

2,8

3,12

4,16

and save the file using the name simple.csv. Note the directory that you are saving it in. Ideally, it should be in a folder named "data".


</div>

### the read.csv function 

```{r read-csv}
fn <- "../data/simple.txt"
raw_data <- 
  read.csv(fn,
    header=TRUE)
```

<div class="notes">

I want to show you how to read data using the readr library. The readr library is part of the tidyverse, and effort by Hadley Wickham and others to modernize the R language. 

Comma separated files are so common that R has several dedicated functions for reading them. The simplest function is read.csv.

In versions of R prior to 4.0, many people, including me, recommended that you use the option stringsAsFactors=FALSE. You will not learn much about strings and factors until the next module, but R used to convert strings into factors by default. This conversion was very unpopular among many R programmers. Factors, you will learn, are great during the data analysis phase, but not during the data management phase of the program.

The R programming team got so many complaints that they changed the default option, starting with R 4.0.0. This may not seem like a lot, but when you change the default option, you pretty much guarantee that thousands of programs will no longer work in the new version of R. You don't want to do this without a very good reason. But the R programming team made the right choice here, in my opinion.

</div>

### Display the csv data

```{r display-csv}
raw_data
```

<div class="notes">

This program reads in the data and displays it. You see the X values one, two, three, four. The Y values: four eight, twelve, and sixteen.

Okay, not too exciting. It's a small data set. You will likely work with some more interesting data sets, but I wanted to show you how this works from a very basic purpose perspective. 

</div>

### Break #1

+ What have you learned
  + Advantages and disadvantages of text files
  + How to read in a comma separated value file
+ What's next?
  + Reading space delimited files
  

### Space delimited files

+ Type the following into notepad.

```{r space-delimited, echo=FALSE, comment=""}
tx <- readLines("../data/simple.txt")
cat(tx, sep="\n")
```

+ Save it
  + in the data directory
  + filename: simple.txt

<div class="notes">

Comma separated values are one of the most common formats you will encounter, but it is not the only format out there.

Now try something different. Type in the same data, but use a spaces between each number rather than a comma. Notice that there are sometimes a single blank between two numbers and sometimes two blanks. This is commonly done with some text files so that the data is easier to read.

We're going to give the file we create a different name. Instead of simple.CSV, we are going to call it simple.txt.

</div>

### Using the read.delim function

```{r txt}
fn <- "../data/simple.txt"
raw_data <- 
  read.delim(fn, 
    header=TRUE,
    sep=" ")
```

<div class="notes">

Review the options for the read.table command.

Type in the same data, but using the tilde (~) as a separator (e.g., 1~4). Save the file as tilde.txt.

Here is how you would use read.table to read this file.

</div>

### Display space-delimted data

```{r display-space}
raw_data
```

<div class="notes">

The data has been read in correctly.

</div>

### Break #2

+ What have you learned
  + Reading space delimited files
+ What's next?
  + Reading tab delimited files  


### Tab delimited files

+ Use the tab key instead of the space bar.

```{r tab, echo=FALSE, comment=""}
tx <- readLines("../data/simple.tsv")
cat(tx, sep="\n")
```

+ Save as simple.tsv

<div class="notes">

Tabs are little bit different and you might want to listen to the live video where I show how the tab key works.

Type the following into notepad and what appears to be multiple blanks, I want you to press the tab key, but only once.

</div>

### Using the read.delim function, again

```{r tsv}
fn <- "../data/simple.tsv"
raw_data <- 
  read.delim(fn, 
    header=TRUE,
    sep="\t")
```

### Display tab-delimted data

```{r display-tab}
raw_data
```

<div class="notes">

The data has been read in correctly.

</div>

### Break #3

+ What have you learned
  + Reading tab delimited files  
+ What's next?
  + Anything can be a delimiter

### Anything can be a delimiter

+ Type the following into notepad

```{r anything, echo=FALSE, comment=""}
tx <- readLines("../data/tilde.txt")
cat(tx, sep="\n")
```

+ Save as tilde.txt


<div class="notes">

Type in the same data, but using the tilde (~) as a separator (e.g., 1~4). Save the file as tilde.txt.

Here is how you would use read.table to read this file.

</div>

### Using the read.table function with sep="~"

```{r tilde}
fn <- "../data/tilde.txt"
raw_data <- 
  read.table(fn,
    header=TRUE,
    sep="~")
```

<div class="notes">

The data reads in just fine. Why would you use a tilde as a delimiter? Sometimes your data itself includes delimiters like spaces and commas, and then you might want to choose an obscure out of the way symbol to serve as a delimiter.

</div>

### Display tilde-delimted data

```{r display-tilde}
raw_data
```

<div class="notes">

The data has been read in correctly.

</div>

### Break #4

+ What have you learned
  + Anything can be a delimiter
+ What's next?
  + Reading fixed width files

### Reading fixed width format files

+ Type the following into notepad
  + Space between the 1 and 4
  + Space between the 2 and 8
  + No space between the 3 and 12
  + No space between the 4 and 16

```{r fixed, echo=FALSE, comment=""}
tx <- readLines("../data/fixed.txt")
cat(tx, sep="\n")
```

+ Save as fixed.txt


<div class="notes">

Here's another variation.

Sometimes you will get a file with no delimiters to save space. This requires that each variable takes up a fixed number of columns and that information is often specified in a separate file.

Create a fixed width file in notepad with the following lines.

1 4

2 8

312

416

and store it as fixed.txt.

Okay, I deliberately did not put the header and here I just said type the numbers because I wanted show you what happens if you don't have a header.

</div>

### The read.fwf function 

```{r read.fwf}
fn <- "../data/fixed.txt"
raw_data <- 
  read.fwf(fn, 
    widths=c(1, 2),
    header=FALSE)
raw_data
```

<div class="notes">

Use the read.fwf (fwf stands for fixed width format) function to read this data.

</div>

### Display the fixed-width data

```{r disaply-fwf}
raw_data
```

<div class="notes">

R does know what to name the variables so it decides to use the default name V1 for the first variable in V2 for the second variable. I do not recommend that you do this if you're creating a file, and if someone else did this, shame, shame on them.

</div>

### Changing names from the default

```{r names}
names(raw_data) <- c("x", "y")
raw_data
```

<div class="notes">

When this happens, add more descriptive names than V1 and V2 as quickly as possible.

Now I have to confess that x and y are not any more descriptive than V1 and V2, but you get the idea.

You should also consider the read.fortran function. Check out the help file.

</div>

### Break #5

+ What have you learned
  + Reading fixed width files
+ What's next?
  + Multiple blanks in a text file
  + Reading character data

### A special case

+ Type the following into notepad
  + Three spaces between the 1 and 4
  + Three spaces between the 2 and 8
  + Two spaces between the 3 and 12
  + Two spaces between the 4 and 16

```{r white-space, echo=FALSE, comment=""}
tx <- readLines("../data/white-space.txt")
cat(tx, sep="\n")
```

+ Save as white-space.txt


<div class="notes">

Here's a special case of fixed width format.

Sometimes a fixed width file will include enough blanks so that each data value is separated from any other data value. This requires more room, but it makes the data file easier to read.
Create a fixed width file in notepad with the following lines.

1   4

2   8

3  12

4  16

and store it as white-space.txt.

</div>

### White-space delimited files

```{r read.table}
fn <- "../data/white-space.txt"
raw_data <- 
  read.table(fn, 
    header=FALSE,
    sep="")
```

<div class="notes">

The argument sep="" will use "white space" as a delimiter. White space is defined as one or more blanks or tabs or even a mix of spaces and tabs.

</div>

### Display the white-space data

```{r disaply-fwf}
raw_data
```

<div class="notes">

The data has been read in properly.

</div>

### Reading character data

+ Character data is data composed of 
  + letters, or
  + a mix of letters, symbols, and numbers
+ Easier in R than in SAS

<div class="notes">

Character data is data that is composed entirely of the letters A-Z upper case and a-z lower case. So a person's name (Steve) is character data. You can also mix in numbers. So a person's address (1600 Pennsylvania Avenue) is character data. A phone number is character data because it might include parentheses or dashes.

R can handle character data more easily than SAS. Often you do not have to do anything and R will figure things out for you. In SAS you ALWAYS have to designate character data. When the lengths of the character data vary, you have to be careful. When the length of the characters is greater than 8, you have to be especially careful.

R can handle varying lengths easily and characters of length greater than 8 easily.

</div>

### Potential problems

+ Values=1, 2, 3 or more
+ Embedded blanks (Steve Simon)
+ Delimiters (Simon, Steve)
+ Recommendation, use quotes
  + "1", "2", "3 or more"
  + "Steve Simon"
  + "Simon, Steve"

<div class="notes">

There still are some issues, such as when the data is mostly numeric, and only sometimes character. An example would be data that has the values 1 (a number), 2 (also a number), and 3 or more (character data).

Embedded blanks are sometimes a problem (Steve space Simon) as are character data that include commonly used delimiters like a comma (simon, comma Steve).

The best thing to do, if there is any potential problems is to enclose your data in quotes.

</div>

### Break #6

+ What have you learned
  + Multiple blanks in a text file
  + Reading character data
+ What's next?
  + Writing text files

### Writing text files

+ Similar structure to read functions
  + write.csv
  + write.table

<div class="notes">

If you want to write a text file, you can use either the write.csv or write.table functions. Look up the help files on these functions. We'll create a small data frame and store it in a comma delimited and tab delimited format.

</div>

### Writing text files 

```{r write-text}
raw_data <- data.frame(x=c(1, 2, 3, 4), y=c(4, 8, 12, 16))
fn <- "../results/output_data.txt"
write.table(
  raw_data, 
  fn, 
  row.names=FALSE)
```

<div class="notes">

Open these files in notepad to see what they look like.

</div>

### Writing text files

```{r output1, echo=FALSE}
tx <- readLines(fn)
cat(tx, sep="\n")
```

<div class="notes">

If you opened up the data in notepad or some other program, you would see a space delimited file. You can change the delimiter, among other things

</div>

### Break #7

+ What have you learned
  + Writing text files
+ What's next?
  + Some real world examples


### Example #1

+ https://stats.idre.ucla.edu/stat/data/binary.csv

```{r ex1, echo=FALSE}
fn <- "https://stats.idre.ucla.edu/stat/data/binary.csv"
tx <- readLines(fn)
cat(tx[1:6], sep="\n")
```

<div class="notes">

Here is the first real-world example. Peeking at the first six lines of data, you can see clearly that it is uses comma delimiter and the first row of data contains the variable names.

</div>


### Example #1

+ No formal data dictionary, but here is a description
  + "This dataset has a binary response (outcome, dependent) variable called admit. There are three predictor variables: gre, gpa and rank. We will treat the variables gre and gpa as continuous. The variable rank takes on the values 1 through 4. Institutions with a rank of 1 have the highest prestige, while those with a rank of 4 have the lowest."
  + Description found at https://stats.idre.ucla.edu/r/dae/logit-regression/
  
<div class="notes">

There is no formal data dictionary, which is a shame, but you can find a brief description on a second page where this data set is used.

</div>

### Example #1

```{r read-binary}
fn <- "https://stats.idre.ucla.edu/stat/data/binary.csv"
mydata <-
  read.csv(fn,
    header=TRUE)
```

<div class="notes">

Choose the read.csv function and the header=TRUE option.

</div>


### Display binary data

```{r display-binary}
head(mydata)
```

<div class="notes">

The read.csv file does a fine job here. I am only printing the first few rows of the data.

</div>

### Example #2

![](../images/barbershop-in-notepad.png)

<div class="notes">

This is a second dataset. Looking at it in notepad, it looks like it is a tab delimited file.

</div>

### Example #2

+ No data dictionary
  + Brief description: "At a barbershop music singing competition, choruses are judged on three scales: Music (quality of the arrangement, etc.), Performance, and Singing."
  + Description found at https://dasl.datadescription.com/datafile/barbershop-music/

### Example #2

```{r read-tsa-3}
fn <- "https://dasl.datadescription.com/download/data/3061"
mydata <- 
  read.delim(fn,
    header=TRUE,
    sep="\t")
```

<div class="notes">

The read.table command works well here. The separator or delimiter is the tab character, which is coded in R as \t.

</div>

### Display barbershop data

```{r display-example-2}
head(mydata)
```

<div class="notes">

The data appears to have been read in nicely.

</div>

### Example #3

![](../images/airport-in-browser.png)

<div class="notes">

This is a third data set. Notice that there are no variable names at the top of the file.

</div>

### Example #3

+ Data dictionary at http://jse.amstat.org/datasets/airport.txt. Here is an excerpt.

```{}
VARIABLE DESCRIPTIONS:
Airport                          Columns 1-21
City                             Columns 22-43 
Scheduled departures             Columns 44-49 
Performed departures             Columns 51-56
Enplaned passengers              Columns 58-65
Enplaned revenue tons of freight Columns 67-75
Enplaned revenue tons of mail    Columns 77-85
```

<div class="notes">

This dataset has a very nice data dictionary. From the description, you can tell that it is a fixed width format.

</div>

### Example #3

```{r airport}
fn <- "http://jse.amstat.org/datasets/airport.dat.txt"
raw_data <- read.fwf(fn, 
  c(21, 22, 6, 7, 9, 10, 10), header=FALSE)
head(raw_data, 2)
```

<div class="notes">

You have to do a bit of math here. If the first variable ends in column 21 and the second variable ends in column 43, then the number of columns for the second variable is 43-21.

</div>

### Should I download before reading?
+ Read directly from website
  + Convenient
  + Updates incorporated at each run
+ Download then read
  + Downloaded file doesn't disappear
  + Avoid repeated long downloads
  + Work even when Internet connection is down
  
<div class="notes">

R gives you the option of reading a file on your computer or reading it from a website. For small datasets that you only use once (such as for your homework assignments), it doesn't matter. For larger files and repeated data analyses, there are some advantages to reading directly from the website and some advantages to downloading the file to your computer. 

Reading directly from the website is convenient. You don't have to figure out where to store your downloaded file. If the website updates the file on a regular basis, reading directly always insures that you have the most current data.

If you download the file and then read it, you provide yourself with some insurance against the website disappearing. If the download takes a long time, then you only have to endure that delay once. Finally, a downloaded file allows you to work when an Internet connection is not available, such as during a plane flight (though many airlines will now let you connect while in the air).

</div>

### Disadvantages of fixed width formatting?
+ Confusing
  + What is 312? 3, 1, and 2? 31, and 2? 3 and 12? 312?
+ More work
+ Prone to errors

<div class="notes">

When you have no delimiters, it is easy to get confused. The third line, for example, of our simple data file is "312". That could be three numbers: 3, 1, and 2. It could be two numbers: 31 and 2? Or maybe 3 and 12? Or it could be a single number: 312. In a small dataset, you won't get confused, but you might with a larger dataset.

It's also more work because you have to specify the number of columns that each variable uses. That's not trivial for a large file.

The fixed width format is also more prone to errors. If you get the columns wrong, you might truncate some of your data.

</div>

### Example where fixed width formatting is needed.

![](../images/ed2017.png)

<div class="notes">

Here's practical example where you really might need fixed width formatting. This is data from Emergency Department visits in a CDC survey. There are over 16,000 rows, which is bad enough. But each row (except the last one) has over 2,400 columns. These columns contain information for over 900 variables.

If you were to use delimiters in this file, you'd have to add 900 commas or 900 tabs or 900 spaces or 900 tildes to each and every line. That works out to be 1.4 million commas across the entire file. That's a substantial increase to the size of an already very large and unwieldy file.

</div>

### No data dictionary?
+ Peek at file
  + Same number of delimiters on each line
+ Tabs versus multiple blanks are hard to distinguish
  + Tab delimited?
  + Space delimited?
  + Fixed width format?
  + http://www.pmean.com/12/pesky.html

<div class="notes">

Many files that you find on the Internet are missing any documentation or the documentation fails to help you figure out what approach to use to import the data. If that's the case, don't despair. There are several common sense things you can try.

First, peek at the file and see if there are any obvious delimiters. It's important that you have the exact same number of delimiters on each line of data. If you think the comma is the delimiter, then if there are five commas on one line, then every line should have five commas. The exception would be delimiters found inside quotes.

Tabs versus multiple blanks are hard to distinguish. This sometimes means that you will have difficulty telling whether to use a tab delimited file, a space delimited file, or a fixed width file. I have a web page that talks about this in detail. 

</div>

### No data dictionary?
+ Experiment
  + Read warnings carefully
+ If needed, edit the file manually
  + Simple edits of one or two offending lines
  + Global search and replace
    + Change tabs to blanks
    + Change multiple blanks to single blank

<div class="notes">

There's nothing wrong with experimenting. Just pick one approach and try it. If you get an error message or the data is garbled, try a different approach. If you get warnings rather than errors, things may be okay, but look carefully at the warning message and double your vigilance efforts before you start analysis.

If all else fails, go in and edit the file manually. This helps if there are just a couple of rows in the file that are causing you heartburn. Usually the error or warning message will give you enough of a hint that you locate the offending lines. If there are problems on every line or almost every line, then sometimes a global search and replace works well.

</div>

### Troubleshooting

+ Multiple data read in as single variable.
+ Lots of missing values

### Summary
+ read.csv for comma delimited files
+ read.table for other delimiters
  + Beware the tab
+ read.fwf for fixed width files
+ write with write.csv, write.table

<div class="notes">

Read data from text files is an important survival skill in R. Use the read.csv function for comma-delimited files. This is the most common format for text files.

Use read.table for other delimiters. Watch out for tab delimited files.

Use read.fwf for fixed width files.

If you need to write text files, the write.csv and write.table functions provide options similar to the two read functions.

</div>
